---
description: Shell scripting safety rules for robust Bash code
globs: vmspawn,helpers/*
alwaysApply: false
---

# Shell Script Safety

## Variable Quoting

Always quote variables -- unquoted expansions break on spaces and trigger globbing:

```bash
# BAD
if [[ -n $STORAGE_CLASS ]] ; then

# GOOD
if [[ -n "$STORAGE_CLASS" ]] ; then
```

## Unset Variables

Use `${VAR:-default}` for variables that may be unset. Never reference a bare `$VAR` that could be empty under `set -eu`:

```bash
# BAD -- exits under set -u if VM_ID is unset
echo "$VM_ID"

# GOOD
echo "${VM_ID:-}"
```

## Pipe Safety

`set -e` does not catch mid-pipe failures. Handle explicitly:

```bash
# BAD -- if oc fails, awk still runs and set -e won't catch it
oc get ns --no-headers | awk '{print $1}'

# GOOD
oc get ns --no-headers 2>/dev/null | awk '{print $1}' || true
```

## Command Substitution

Use `$(command)`, never backticks.

## No eval

Never use `eval`. Use arrays for dynamic commands.

## oc Commands That May Fail

For `oc` commands where failure is a valid outcome (e.g. checking if a resource exists), always append `|| true` or handle the error path:

```bash
detected=$(oc get storageprofile "$STORAGE_CLASS" \
    -o jsonpath='{.status.claimPropertySets[0].accessModes[0]}' \
    2>/dev/null) || true
```

## Stderr Suppression

Only redirect stderr to `/dev/null` when the error is expected and handled. Never silently discard unexpected errors.

## Command Existence Checks

Use `[[ -z "$(type -t cmd)" ]]` to check for commands (matching existing project pattern).
